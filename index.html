<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kent每天都要进步</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="勿在浮沙筑高台">
<meta property="og:type" content="website">
<meta property="og:title" content="kent每天都要进步">
<meta property="og:url" content="http://blog.xuguruogu.com/index.html">
<meta property="og:site_name" content="kent每天都要进步">
<meta property="og:description" content="勿在浮沙筑高台">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kent每天都要进步">
<meta name="twitter:description" content="勿在浮沙筑高台">
  
    <link rel="alternate" href="/atom.xml" title="kent每天都要进步" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kent每天都要进步</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">ITer的觉悟</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.xuguruogu.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-proc-irq-number-smp-affinity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/30/proc-irq-number-smp-affinity/" class="article-date">
  <time datetime="2017-03-30T05:56:55.000Z" itemprop="datePublished">2017-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/30/proc-irq-number-smp-affinity/">/proc/irq/{number}/smp_affinity</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在多 CPU 的环境中，还有一个中断平衡的问题，比如，网卡中断会教给哪个 CPU 处理，这个参数控制哪些 CPU 可以绑定 IRQ 中断。其中的 {number} 是对应设备的中断编号，可以用下面的命令找出：<br>cat /proc/interrupt<br>比如，一般 eth0 的 IRQ 编号是 16，所以控制 eth0 中断绑定的 /proc 文件名是 /proc/irq/16/smp_affinity。上面这个命令还可以看到某些中断对应的CPU处理的次数，缺省的时候肯定是不平衡的。<br>设置其值的方法很简单，smp_affinity 自身是一个位掩码（bitmask），特定的位对应特定的 CPU，这样，01 就意味着只有第一个 CPU 可以处理对应的中断，而 0f（0x1111）意味着四个 CPU 都会参与中断处理。<br>几乎所有外设都有这个参数设置，可以关注一下。<br>这个数值的推荐设置，其实在很大程度上，让专门的CPU处理专门的中断是效率最高的，比如，给磁盘IO一个CPU，给网卡一个CPU，这样是比较合理的。</p>
<p><a href="https://cs.uwaterloo.ca/~brecht/servers/apic/SMP-affinity.txt" target="_blank" rel="external">SMP IRQ Affinity</a></p>
<p>Background:  </p>
<p>Whenever a piece of hardware, such as disk controller or ethernet card,<br>needs attention from the CPU, it throws an interrupt.  The interrupt tells<br>the CPU that something has happened and that the CPU should drop what<br>it’s doing to handle the event.  In order to prevent mutliple devices from<br>sending the same interrupts, the IRQ system was established where each device<br>in a computer system is assigned its own special IRQ so that its interrupts<br>are unique.</p>
<p>Starting with the 2.4 kernel, Linux has gained the ability to assign certain<br>IRQs to specific processors (or groups of processors).  This is known<br>as SMP IRQ affinity, and it allows you control how your system will respond<br>to various hardware events.  It allows you to restrict or repartition<br>the work load that you server must do so that it can more efficiently do<br>it’s job.</p>
<p>Obviously, in order for this to work, you will need a system that has more<br>than one processor (SMP).  You will also need to be running a 2.4 or higher<br>kernel.</p>
<p>Some brief and very bare information on SMP IRQ affinity is provided in<br>the kernel source tree of the 2.4 kernel in the file:</p>
<pre><code>/usr/src/linux-2.4/Documentation/IRQ-affinity.txt
</code></pre><p>How to use it:</p>
<p>SMP affinity is controlled by manipulating files in the /proc/irq/ directory.<br>In /proc/irq/ are directories that correspond to the IRQs present on your<br>system (not all IRQs may be available). In each of these directories is<br>the “smp_affinity” file, and this is where we will work our magic.</p>
<p>The first order of business is to figure out what IRQ a device is using.<br>This information is available in the /proc/interrupts file.  Here’s a sample:</p>
<p> [root@archimedes /proc]# cat /proc/interrupts<br>            CPU0       CPU1       CPU2       CPU3<br>   0:    4865302    5084964    4917705    5017077    IO-APIC-edge  timer<br>   1:        132        108        159        113    IO-APIC-edge  keyboard<br>   2:          0          0          0          0          XT-PIC  cascade<br>   8:          0          1          0          0    IO-APIC-edge  rtc<br>  10:          0          0          0          0   IO-APIC-level  usb-ohci<br>  14:          0          0          1          1    IO-APIC-edge  ide0<br>  24:      87298      86066      86012      86626   IO-APIC-level  aic7xxx<br>  31:      93707     106211     107988      93329   IO-APIC-level  eth0<br> NMI:          0          0          0          0<br> LOC:   19883500   19883555   19883441   19883424<br> ERR:          0<br> MIS:          0</p>
<p>As you can see, this is a 4 processor machine.  The first column (unlabelled)<br>lists the IRQs used on the system.  The rows with letters (ie, “NMI”, “LOC”)<br>are parts of other drivers used on the system and aren’t really accessible<br>to us, so we’ll just ignore them.</p>
<p>The second through fifth columns (labelled CPU0-CPU3) show the number of times<br>the corresponding process has handled an interrupt from that particular IRQ.<br>For example, all of the CPUs have handled roughly the same number of interrupts<br>for IRQ 24 (around 86,000 with CPU0 handling a little over 87,000).</p>
<p>The sixth column lists whether or not the device driver associated with the<br>interrupt supports IO-APIC (see /usr/src/linux/Documentation/i386/IO-APIC.txt<br>for more information).  The only reason to look at this value is that<br>SMP affinity will only work for IO-APIC enabled device drivers.  For<br>example, we will not be able to change the affinity for the “cascade”<br>driver (IRQ 2) because it doesn’t support IO-APIC.</p>
<p>Finally, the seventh and last column lists the driver or device that is<br>associated with the interrupt.  In the above example, our ethernet card<br>(eth0) is using IRQ 31, and our SCSI controller (aic7xxx) is using IRQ 24.</p>
<p>The first and last columns are really the only ones we’re interested in here.<br>For the rest of this example, I’m going to assume that we want to adjust<br>the SMP affinity for th SCSI controller (IRQ 24).</p>
<p>Now that we’ve got the IRQ, we can change the processor affinity.  To<br>do this, we’ll go into the /proc/irq/24/ directory, and see what the<br>affinity is currently set to:</p>
<p> [root@archimedes Documentation]# cat /proc/irq/24/smp_affinity<br> ffffffff</p>
<p>This is a bitmask that represents which processors any interrupts on IRQ<br>24 should be routed to.  Each field in the bit mask corresponds to a processor.<br>The number held in the “smp_affinity” file is presented in hexadecimal format,<br>so in order to manipulate it properly we will need to convert our bit patterns<br>from binary to hex before setting them in the proc file.</p>
<p>Each of the “f”s above represents a group of 4 CPUs, with the rightmost<br>group being the least significant.  For the purposes of our discussion,<br>we’re going to limit ourselves to only the first 4 CPUs (although we can<br>address up to 32).</p>
<p>In short, this means you only have to worry about the rightmost “f” and you<br>can assume everything else is a “0” (ie, our bitmask is “0000000f”).</p>
<p>“f” is the hexadecimal represenatation for the decimal number 15 (fifteen)<br>and the binary pattern of “1111”.  Each of the places in the binary pattern<br>corresponds to a CPU in the server, which means we can use the following<br>chart to represent the CPU bit patterns:</p>
<pre><code>        Binary       Hex 
CPU 0    0001         1 
CPU 1    0010         2
CPU 2    0100         4
CPU 3    1000         8
</code></pre><p>By combining these bit patterns (basically, just adding the Hex values), we<br>can address more than one processor at a time.   For example, if I wanted<br>to talk to both CPU0 and CPU2 at the same time, the result is:</p>
<pre><code>        Binary       Hex 
CPU 0    0001         1 
</code></pre><h2 id="CPU-2-0100-4"><a href="#CPU-2-0100-4" class="headerlink" title="  + CPU 2    0100         4"></a>  + CPU 2    0100         4</h2><pre><code>both     0101         5
</code></pre><p>If I want to address all four of the processors at once, then the result is:</p>
<pre><code>        Binary       Hex 
CPU 0    0001         1 
CPU 1    0010         2
CPU 2    0100         4
</code></pre><h2 id="CPU-3-1000-8"><a href="#CPU-3-1000-8" class="headerlink" title="  + CPU 3    1000         8"></a>  + CPU 3    1000         8</h2><pre><code>both     1111         f
</code></pre><p>(Remember that we use the letters “a” through “f” to represent the numbers<br> “10” to “15” in hex notation).</p>
<p>Given that, we now know that if we have a four processor system, we can<br>assign any of 15 different CPU combinations to an IRQ (it would be 16, but<br>it isn’t legal to assign an IRQ affinity of “0” to any IRQ… if you try,<br>Linux will just ignore your attempt).</p>
<p>So.  Now we get to the fun part.  Remember in our /proc/interrupts listing<br>above that all four of our CPUs had handled the close to the same amount of<br>interrupts for our SCSI card?  We now have the tools needed to limit managing<br>the SCSI card to just one processor and leave the other three free to<br>concentrate on doing other tasks.   Let’s assume that we want to dedicate<br>our first CPU (CPU0) to handling the SCSI controller interrupts.  To do this,<br>we would simply run the following command:</p>
<p> [root@archimedes /proc]# echo 1 &gt; /proc/irq/24/smp_affinity<br> [root@archimedes /proc]# cat /proc/irq/24/smp_affinity<br> 00000001</p>
<p>Now, let’s test it out and see what happens:</p>
<p> [root@archimedes /proc]# cd /tmp/<br> [root@archimedes /tmp]# tar -zcf test.tgz /usr/src/linux-2.4.2<br> tar: Removing leading `/‘ from member names<br> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br> [root@archimedes /tmp]# cat /proc/interrupts | grep 24:<br>  24:      99719      86067      86012      86627   IO-APIC-level  aic7xxx</p>
<p>Compare that to the previous run without having the IRQ bound to CPU0:</p>
<p>  24:      87298      86066      86012      86626   IO-APIC-level  aic7xxx</p>
<p>All of the interrupts from the disk controller are now handled exclusively<br>by the first CPU (CPU0), which means that our other 3 proccessors are free<br>to do other stuff now.</p>
<p>Finally, it should be pointed out that if you decide you no longer want<br>SMP affinity and would rather have the system revert back to the old set up,<br>then you can simply do:</p>
<p> [root@archimedes /tmp]# cat /proc/irq/prof_cpu_mask &gt;/proc/irq/24/smp_affinity</p>
<p>This will reset the “smp_affinity” file to use all “f”s, and will return to<br>the load sharing arrangement that we saw earlier.</p>
<p>What can I use it for?</p>
<ul>
<li><p>“balance” out multiple NICs in a multi-processor machine.  By tying a single<br>NIC to a single CPU, you should be able to scale the amount of traffic<br>your server can handle nicely.</p>
</li>
<li><p>database servers (or servers with lots of disk storage) that also have<br>heavy network loads can dedicate a CPU to their disk controller and assign<br>another to deal with the NIC to help improve response times.</p>
</li>
</ul>
<p>Can I do this with processes?</p>
<p>At this time, no.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.xuguruogu.com/2017/03/30/proc-irq-number-smp-affinity/" data-id="cj0vzoczh0003ges69rrtix8b" class="article-share-link">Compartir</a>
      
        <a href="http://blog.xuguruogu.com/2017/03/30/proc-irq-number-smp-affinity/#disqus_thread" class="article-comment-link">Comentarios</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="top-cpu含义" class="article article-type-top" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/30/cpu含义/" class="article-date">
  <time datetime="2017-03-30T05:52:25.000Z" itemprop="datePublished">2017-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/30/cpu含义/">cpu含义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用系统命令top即可看到如下类似信息：</p>
<p>Cpu(s):  0.0%us,  0.5%sy,  0.0%ni, 99.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</p>
<p>us: is meaning of “user CPU time”<br>sy: is meaning of “system CPU time”<br>ni: is meaning of” nice CPU time”<br>id: is meaning of “idle”<br>wa: is meaning of “iowait”<br>hi：is meaning of “hardware irq”<br>si : is meaning of “software irq”<br>st : is meaning of “steal time”</p>
<p>us 用户空间占用CPU百分比<br>sy 内核空间占用CPU百分比<br>ni 用户进程空间内改变过优先级的进程占用CPU百分比<br>id 空闲CPU百分比<br>wa 等待输入输出的CPU时间百分比<br>hi 硬件中断<br>si 软件中断<br>st: 实时</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.xuguruogu.com/2017/03/30/cpu含义/" data-id="cj0vzocyv0000ges6x523zov3" class="article-share-link">Compartir</a>
      
        <a href="http://blog.xuguruogu.com/2017/03/30/cpu含义/#disqus_thread" class="article-comment-link">Comentarios</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux下cpu物理个数、多核、超线程判断解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/30/linux下cpu物理个数、多核、超线程判断解析/" class="article-date">
  <time datetime="2017-03-30T03:10:29.000Z" itemprop="datePublished">2017-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/30/linux下cpu物理个数、多核、超线程判断解析/">linux下cpu物理个数、多核、超线程判断解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux体系中，供给了proc文件体系显示体系的软硬件信息。若是想懂得体系中CPU的供给商和相干设备信息，则可以经由过程/proc/cpuinfo文件获得。本文章针对该文件进行简单的总结。</p>
<p>基于指令集（ISA）的CPU产生的/proc/cpuinfo文件不一样，基于X86指令集CPU的/proc/cpuinfo文件包含如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">processor       : 0</div><div class="line">vendor_id       : GenuineIntel</div><div class="line">cpu family      : 6</div><div class="line">model           : 23</div><div class="line">model name      : Intel(R) Xeon(R) CPU           E5430  @ 2.66GHz</div><div class="line">stepping        : 10</div><div class="line">cpu MHz         : 2666.890</div><div class="line">cache size      : 6144 KB</div><div class="line">physical id     : 0</div><div class="line">siblings        : 4</div><div class="line">core id         : 0</div><div class="line">cpu cores       : 4</div><div class="line">apicid          : 0</div><div class="line">initial apicid  : 0</div><div class="line">fpu             : yes</div><div class="line">fpu_exception   : yes</div><div class="line">cpuid level     : 13</div><div class="line">wp              : yes</div><div class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm constant_tsc arch_perfmon pebs bts rep_good aperfmperf pni tm2 ssse3 lahf_lm dts</div><div class="line">bogomips        : 5333.78</div><div class="line">clflush size    : 64</div><div class="line">cache_alignment : 64</div><div class="line">address sizes   : 38 bits physical, 48 bits virtual</div><div class="line">power management:</div></pre></td></tr></table></figure>
<p>以上输出项的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">processor　：体系中逻辑处理惩罚核的编号。对于单核处理惩罚器，则课认为是其CPU编号，对于多核处理惩罚器则可所以物理核、或者应用超线程技巧虚拟的逻辑核</div><div class="line">vendor_id　：CPU建造商      </div><div class="line">cpu family　：CPU产品系列代号</div><div class="line">model　　　：CPU属于其系列中的哪一代的代号</div><div class="line">model name：CPU属于的名字及其编号、标称主频</div><div class="line">stepping　  ：CPU属于建造更新版本</div><div class="line">cpu MHz　  ：CPU的实际应用主频</div><div class="line">cache size   ：CPU二级缓存大小</div><div class="line">physical id   ：单个CPU的标号</div><div class="line">siblings       ：单个CPU逻辑物理核数</div><div class="line">core id        ：当前物理核在其所处CPU中的编号，这个编号不必然连气儿</div><div class="line">cpu cores    ：该逻辑核所处CPU的物理核数</div><div class="line">apicid          ：用来区分不合逻辑核的编号，体系中每个逻辑核的此编号必定不合，此编号不必然连气儿</div><div class="line">fpu             ：是否具有浮点运算单位（Floating Point Unit）</div><div class="line">fpu_exception  ：是否支撑浮点策画异常</div><div class="line">cpuid level   ：履行cpuid指令前，eax存放器中的值，按照不合的值cpuid指令会返回不合的内容</div><div class="line">wp             ：注解当前CPU是否在内核态支撑对用户空间的写保护（Write Protection）</div><div class="line">flags          ：当前CPU支撑的功能</div><div class="line">bogomips   ：在体系内核启动时粗略测算的CPU速度（Million Instructions Per Second）</div><div class="line">clflush size  ：每次刷新缓存的大小单位</div><div class="line">cache_alignment ：缓存地址对齐单位</div><div class="line">address sizes     ：可接见地址空间位数</div><div class="line">power management ：对能源经管的支撑</div></pre></td></tr></table></figure>
<p>CPU信息中flags各项含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">fpu： Onboard （x87） Floating Point Unit</div><div class="line">vme： Virtual Mode Extension</div><div class="line">de： Debugging Extensions</div><div class="line">pse： Page Size Extensions</div><div class="line">tsc： Time Stamp Counter: support for RDTSC and WRTSC instructions</div><div class="line">msr： Model-Specific Registers</div><div class="line">pae： Physical Address Extensions: ability to access 64GB of memory; only 4GB can be accessed at a time though</div><div class="line">mce： Machine Check Architecture</div><div class="line">cx8： CMPXCHG8 instruction</div><div class="line">apic： Onboard Advanced Programmable Interrupt Controller</div><div class="line">sep： Sysenter/Sy***it Instructions; SYSENTER is used for jumps to kernel memory during system calls， and SY***IT is used for jumps： back to the user code</div><div class="line">mtrr： Memory Type Range Registers</div><div class="line">pge： Page Global Enable</div><div class="line">mca： Machine Check Architecture</div><div class="line">cmov： CMOV instruction</div><div class="line">pat： Page Attribute Table</div><div class="line">pse36： 36-bit Page Size Extensions: allows to map 4 MB pages into the first 64GB RAM， used with PSE.</div><div class="line">pn： Processor Serial-Number; only available on Pentium 3</div><div class="line">clflush： CLFLUSH instruction</div><div class="line">dtes： Debug Trace Store</div><div class="line">acpi： ACPI via MSR</div><div class="line">mmx： MultiMedia Extension</div><div class="line">fxsr： FXSAVE and FXSTOR instructions</div><div class="line">sse： Streaming SIMD Extensions. Single instruction multiple data. Lets you do a bunch of the same operation on different pieces of input： in a single clock tick.</div><div class="line">sse2： Streaming SIMD Extensions-2. More of the same.</div><div class="line">selfsnoop： CPU self snoop</div><div class="line">acc： Automatic Clock Control</div><div class="line">IA64： IA-64 processor Itanium.</div><div class="line">ht： HyperThreading. Introduces an imaginary second processor that doesn’t do much but lets you run threads in the same process a  bit quicker.</div><div class="line">nx： No ute bit. Prevents arbitrary code running via buffer overflows.</div><div class="line">pni： Prescott New Instructions aka. SSE3</div><div class="line">vmx： Intel Vanderpool hardware virtualization technology</div><div class="line">svm： AMD “Pacifica” hardware virtualization technology</div><div class="line">lm： “Long Mode，” which means the chip supports the AMD64 instruction set</div><div class="line">tm： “Thermal Monitor” Thermal throttling with IDLE instructions. Usually hardware controlled in response to CPU temperature.</div><div class="line">tm2： “Thermal Monitor 2″ Decrease speed by reducing multipler and vcore.</div><div class="line">est： “Enhanced SpeedStep”</div></pre></td></tr></table></figure>
<ul>
<li>查看CPU信息命令<br>cat /proc/cpuinfo</li>
<li>查看内存信息命令<br>cat /proc/meminfo</li>
<li><p>查看硬盘信息命令<br>fdisk -l</p>
</li>
<li><p>查询体系CPU的物理个数<br>  cat /proc/cpuinfo |grep “physical id”|sort |uniq|wc -l</p>
</li>
<li>查询体系具有几许个逻辑核<br>  cat /proc/cpuinfo | grep “processor” | wc -l</li>
<li>查询体系CPU的物理核数<br>  cat /proc/cpuinfo | grep “cpu cores” | uniq</li>
<li>查询体系CPU是否启用超线程<br>  cat /proc/cpuinfo | grep -e “cpu cores”  -e “siblings” | sort | uniq</li>
<li>查询CPU的主频<br>  cat /proc/cpuinfo |grep MHz|uniq<br>  输出举例：<br>  cpu cores    : 6<br>  siblings    　: 6</li>
<li>查看当前系统内核信息<br>  uname -a<br>  Linux localhost.localdomain 2.6.32-220.el6.x86_64 #1 SMP Tue Dec 6 19:48:22 GMT2011x86_64 x86_64 x86_64 GNU/Linux</li>
<li><p>查看当前操作系统发行版信息：<br>  cat /etc/issue | grep Linux<br>  Red Hat Enterprise Linux AS release 4 (Nahant Update 5)</p>
</li>
<li><p>查看逻辑CPU、CPU型号<br>  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c<br>  8  Intel(R) Xeon(R) CPU            E5410   @ 2.33GHz</p>
</li>
<li><p>查看物理核心</p>
<h1 id="cat-proc-cpuinfo-grep-physical-uniq-c"><a href="#cat-proc-cpuinfo-grep-physical-uniq-c" class="headerlink" title="cat /proc/cpuinfo | grep physical | uniq -c"></a>cat /proc/cpuinfo | grep physical | uniq -c</h1><p>  4 physical id      : 0<br>  4 physical id      : 1<br>  (说明实际上是两颗4核的CPU)</p>
</li>
<li><p>32/64位</p>
<h1 id="getconf-LONG-BIT"><a href="#getconf-LONG-BIT" class="headerlink" title="getconf LONG_BIT"></a>getconf LONG_BIT</h1><p>  32<br>  (说明当前CPU运行在32bit模式下, 但不代表CPU不支持64bit)</p>
</li>
<li><h1 id="cat-proc-cpuinfo-grep-flags-grep-‘-lm-‘-wc-l"><a href="#cat-proc-cpuinfo-grep-flags-grep-‘-lm-‘-wc-l" class="headerlink" title="cat /proc/cpuinfo | grep flags | grep ‘ lm ‘ | wc -l"></a>cat /proc/cpuinfo | grep flags | grep ‘ lm ‘ | wc -l</h1><p>  8<br>  (结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit)</p>
</li>
<li><p>若是cpu cores数量和siblings数量一致，则没有启用超线程，不然超线程被启用。</p>
</li>
</ul>
<p>查询体系CPU是否支撑某项功能，则根以上类似，输出成果进行sort， uniq和grep就可以获得成果。<br>processor 条目包括这一逻辑处理器的唯一标识符。<br>physical id 条目包括每个物理封装的唯一标识符。<br>core id 条目保存每个内核的唯一标识符。<br>siblings 条目列出了位于相同物理封装中的逻辑处理器的数量。<br>cpu cores 条目包含位于相同物理封装中的内核数量。<br>如果处理器为英特尔处理器，则 vendor id 条目中的字符串是 GenuineIntel。<br>拥有相同 physical id 的所有逻辑处理器共享同一个物理插座。每个 physical id 代表一个唯一的物理封装。Siblings 表示位于这一物理封装上的逻辑处理器的数量。它们可能支持也可能不支持超线程（HT）技术。每个 core id 均代表一个唯一的处理器内核。所有带有相同 core id 的逻辑处理器均位于同一个处理器内核上。如果有一个以上逻辑处理器拥有相同的 core id 和 physical id，则说明系统支持超线程（HT）技术。如果有两个或两个以上的逻辑处理器拥有相同的 physical id，但是 core id 不同，则说明这是一个多内核处理器。cpu cores 条目也可以表示是否支持多内核。<br>例如，如果系统包含两个物理封装，每个封装中又包含两个支持超线程（HT）技术的处理器内核，则 /proc/cpuinfo 文件将包含此数据。（注：数据并不在表格中。）</p>
<p>?processor ?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7<br>?physical id ?0 ?1 ?0 ?1 ?0 ?1 ?0 ?1<br>?core id ?0 2 1 ?3 ?0 ?2 ?1 ?3<br>?siblings ?4 ?4 ?4 ?4 ?4 ?4 ?4 ?4<br>?cpu cores ?2 ?2 ?2 ?2 ?2 ?2 ?2 ?2</p>
<p>此例说明逻辑处理器 0 和 4 驻留在物理封装 0 的内核 0 上。这就表示逻辑处理器 0 和 4 支持超线程（HT）技术。相同的工作可用于封装 0 内核 1 上的逻辑处理器 2 和 6，封装 1 内核 2 上的逻辑处理器 1 和 5，以及封装 1 内核 3 上的逻辑处理器 3 和 7。此系统支持超线程（HT）技术，因为两个逻辑处理器共享同一个内核。有两种方式可以确定是否支持多内核。由于内核 0 和 1 存在于封装 0 上，而内核 2 和 3 存在于封装 1 上，所以这是一个多内核系统。此外，cpu cores 条目为 2，也说明有两个内核驻留在物理封装中。这是一个多路系统，因为有两个封装。值得注意的是 physical id 和 core id 的编号可能是也可能不是连续的。系统上有两个物理封装并不罕见，而且 physical id 等于 0 和 3</p>
<p>CPU ID<br>CPU ID是CPU生产厂家为识别不同类型的CPU，而为CPU制订的不同的单一的代码；不同厂家的CPU，其CPU ID定义也是不同的；如 “0F24”（Inter处理器）、“681H”（AMD处理器），根据这些数字代码即可判断CPU属于哪种类型，这就是一般意义上的CPU ID。 由于计算机使用的是十六进制，因此CPU ID也是以十六进制表示的。Inter处理器的CPU ID一共包含四个数字，如“0F24”，从左至右分别表示 Type（类型）、Family（系列）、Mode（型号）和Stepping（步进编号）。从CPUID为“068X”的处理器开始，Inter另外增 加了Brand ID（品种标识）用来辅助应用程序识别CPU的类型，因此根据“068X”CPUID还不能正确判别Pentium和Celerom处理 器。必须配合Brand ID来进行细分。AMD处理器一般分为三位，如“681”，从左至右分别表示为Family（系列）、Mode（型号）和 Stepping（步进编号）。</p>
<p>Type（类型）<br>类型标识用来区别INTEL微处理器是用于由最终用户安装，还是由专业个人计算机系 统集成商、服务公司或制作商安装；数字“1”标识所测试的微处理器是用于由用户安装的；数字“0”标识所测试的微处理器是用于由专业个人计算机系统集成 商、服务公司或制作商安装的。我们通常使用的INTEL处理器类型标识都是“0”，“0F24”CPUID就属于这种类型。</p>
<p>Family（系列）<br>系 列标识可用来确定处理器属于那一代产品。如6系列的INTEL处理器包括Pentium Pro、Pentium II、 Pentium II Xeon、Pentium III和Pentium III Xeon处理器。5系列（第五代）包括Pentium处理器和采用 MMX技术的Pentium处理器。AMD的6系列实际指有K7系列CPU，有DURON和ATHION两大类。最新一代的 INTEL Pentium 4系列处理器（包括相同核心的Celerom处理器）的系列值为“F”</p>
<p>Mode（型号）<br>型号标识可用来 确定处理器的制作技术以及属于该系列的第几代设计（或核心），型号与系列通常是相互配合使用的，用于确定计算机所安装的处理器是属于某系列处理器的哪种特 定类型。如可确定Celerom处理器是Coppermine还是Tualutin核心；Athlon XP处理器是Paiomino还是 Thorouhgbred核心。</p>
<p>Stepping（步进编号）<br>步进编号用来标识处理器的设计或制作版本，有助于控制和跟踪处理器的更 改，步进还可以让最终用户更具体地识别其系统安装的处理器版本，确定微处理器的内部设计或制作特性。步进编号就好比处理器的小版本号，如CPUID为 “686”和“686A”就好比WINZIP8.0和8.1的关系。步进编号和核心步进是密切联系的。如CPUID为“686”的Pentium III 处理器是cCO核心，而“686A”表示的是更新版本cD0核心。</p>
<p>Brand ID（品种标识）<br>INTEL从Coppermine核心的处理器开始引入Brand ID作为CPU的辅助识别手段。如我们通过Brand ID可以识别出处理器究竟是Celerom还是Pentium 4。</p>
<p>在LINUX系统中，一颗超线程CPU，将被识别为两颗CPU，一颗双核CPU，也被识别为两颗CPU，而一颗双核超线程CPU，会被认为是4颗CPU。那么，我们如何确定我们机器的CPU数量呢？</p>
<p>仔细查看/proc/cpuinfo我们会发现以下信息：</p>
<ul>
<li>physical id代表每颗物理CPU的ID，有几个CPU ID，就有几颗物理CPU。</li>
<li>siblings区别出了超线程CPU中的逻辑CPU核心，一颗超线程CPU，其physical id是一样的，但是siblings是不同的。</li>
<li>core id和cpu cores用来对双核（多核心）CPU进行区分的，CPU cores表示这颗CPU有几个核心，而core id用来表示CPU的各个核心的。</li>
</ul>
<p>例如：如何区分一颗双核超线程CPU？<br>cat /etc/proc/cpuinfo<br>{<br>physical id=0  （1颗物理CPU）<br>  [<br>  core id=0    （双核CPU中的第一个核心）<br>  cpu cores=2  （双核CPU）<br>    siblings=0 （此核心中的第一个逻辑CPU）<br>    siblings=1 （此核心中的另一个逻辑CPU）<br>  ]<br>  [<br>  core id=1    （双核CPU中的另一个核心）<br>  cpu cores=2  （双核CPU）<br>    siblings=0 （此核心中的第一个逻辑CPU）<br>    siblings=1 （此核心中的另一个逻辑CPU）<br>  ]<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.xuguruogu.com/2017/03/30/linux下cpu物理个数、多核、超线程判断解析/" data-id="cj0vzoczk0004ges63y8de6ru" class="article-share-link">Compartir</a>
      
        <a href="http://blog.xuguruogu.com/2017/03/30/linux下cpu物理个数、多核、超线程判断解析/#disqus_thread" class="article-comment-link">Comentarios</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux系统调用列表-收藏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/Linux系统调用列表-收藏/" class="article-date">
  <time datetime="2017-03-22T16:14:08.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/Linux系统调用列表-收藏/">Linux系统调用列表(收藏)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下是Linux系统调用的一个列表，包含了大部分常用系统调用和由系统调用派生出的的函数。这可能是你在互联网上所能看到的唯一一篇中文注释的Linux系统调用列表，即使是简单的字母序英文列表，能做到这么完全也是很罕见的。</p>
<p>按照惯例，这个列表以man pages第2节，即系统调用节为蓝本。按照笔者的理解，对其作了大致的分类，同时也作了一些小小的修改，删去了几个仅供内核使用，不允许用户调用的系统调用，对个别本人稍觉不妥的地方作了一些小的修改，并对所有列出的系统调用附上简要注释。　　</p>
<p>其中有一些函数的作用完全相同，只是参数不同。（可能很多熟悉C++朋友马上就能联想起函数重载，但是别忘了Linux核心是用C语言写的，所以只能取成不同的函数名）。还有一些函数已经过时，被新的更好的函数所代替了（gcc在链接这些函数时会发出警告），但因为兼容的原因还保留着，这些函数我会在前面标上“*”号以示区别。</p>
<ul>
<li>进程控制：</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>创建一个新进程</td>
</tr>
<tr>
<td>clone</td>
<td>按指定条件创建子进程</td>
</tr>
<tr>
<td>execve</td>
<td>运行可执行文件</td>
</tr>
<tr>
<td>exit</td>
<td>中止进程</td>
</tr>
<tr>
<td>_exit</td>
<td>立即中止当前进程</td>
</tr>
<tr>
<td>getdtablesize</td>
<td>进程所能打开的最大文件数</td>
</tr>
<tr>
<td>getpgid</td>
<td>获取指定进程组标识号</td>
</tr>
<tr>
<td>setpgid</td>
<td>设置指定进程组标志号</td>
</tr>
<tr>
<td>getpgrp</td>
<td>获取当前进程组标识号</td>
</tr>
<tr>
<td>setpgrp</td>
<td>设置当前进程组标志号</td>
</tr>
<tr>
<td>getpid</td>
<td>获取进程标识号</td>
</tr>
<tr>
<td>getppid</td>
<td>获取父进程标识号</td>
</tr>
<tr>
<td>getpriority</td>
<td>获取调度优先级</td>
</tr>
<tr>
<td>setpriority</td>
<td>设置调度优先级</td>
</tr>
<tr>
<td>modify_ldt</td>
<td>读写进程的本地描述表</td>
</tr>
<tr>
<td>nanosleep</td>
<td>使进程睡眠指定的时间</td>
</tr>
<tr>
<td>nice</td>
<td>改变分时进程的优先级</td>
</tr>
<tr>
<td>pause</td>
<td>挂起进程，等待信号</td>
</tr>
<tr>
<td>personality</td>
<td>设置进程运行域</td>
</tr>
<tr>
<td>prctl</td>
<td>对进程进行特定操作</td>
</tr>
<tr>
<td>ptrace</td>
<td>进程跟踪</td>
</tr>
<tr>
<td>sched_get_priority_max</td>
<td>取得静态优先级的上限</td>
</tr>
<tr>
<td>sched_get_priority_min</td>
<td>取得静态优先级的下限</td>
</tr>
<tr>
<td>sched_getparam</td>
<td>取得进程的调度参数</td>
</tr>
<tr>
<td>sched_getscheduler</td>
<td>取得指定进程的调度策略</td>
</tr>
<tr>
<td>sched_rr_get_interval</td>
<td>取得按RR算法调度的实时进程的时间片长度</td>
</tr>
<tr>
<td>sched_setparam</td>
<td>设置进程的调度参数</td>
</tr>
<tr>
<td>sched_setscheduler</td>
<td>设置指定进程的调度策略和参数</td>
</tr>
<tr>
<td>sched_yield</td>
<td>进程主动让出处理器,并将自己等候调度队列队尾</td>
</tr>
<tr>
<td>vfork</td>
<td>创建一个子进程，以供执行新程序，常与execve等同时使用</td>
</tr>
<tr>
<td>wait</td>
<td>等待子进程终止</td>
</tr>
<tr>
<td>wait3</td>
<td>参见wait</td>
</tr>
<tr>
<td>waitpid</td>
<td>等待指定子进程终止</td>
</tr>
<tr>
<td>wait4</td>
<td>参见waitpid</td>
</tr>
<tr>
<td>capget</td>
<td>获取进程权限</td>
</tr>
<tr>
<td>capset</td>
<td>设置进程权限</td>
</tr>
<tr>
<td>getsid</td>
<td>获取会晤标识号</td>
</tr>
<tr>
<td>setsid</td>
<td>设置会晤标识号</td>
</tr>
</tbody>
</table>
<ul>
<li>文件系统控制<ul>
<li>文件读写操作</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fcntl</td>
<td>文件控制</td>
</tr>
<tr>
<td>open</td>
<td>打开文件</td>
</tr>
<tr>
<td>creat</td>
<td>创建新文件</td>
</tr>
<tr>
<td>close</td>
<td>关闭文件描述字</td>
</tr>
<tr>
<td>read</td>
<td>读文件</td>
</tr>
<tr>
<td>write</td>
<td>写文件</td>
</tr>
<tr>
<td>readv</td>
<td>从文件读入数据到缓冲数组中</td>
</tr>
<tr>
<td>writev</td>
<td>将缓冲数组里的数据写入文件</td>
</tr>
<tr>
<td>pread</td>
<td>对文件随机读</td>
</tr>
<tr>
<td>pwrite</td>
<td>对文件随机写</td>
</tr>
<tr>
<td>lseek</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>_llseek</td>
<td>在64位地址空间里移动文件指针</td>
</tr>
<tr>
<td>dup</td>
<td>复制已打开的文件描述字</td>
</tr>
<tr>
<td>dup2</td>
<td>按指定条件复制文件描述字</td>
</tr>
<tr>
<td>flock</td>
<td>文件加/解锁</td>
</tr>
<tr>
<td>poll</td>
<td>I/O多路转换</td>
</tr>
<tr>
<td>truncate</td>
<td>截断文件</td>
</tr>
<tr>
<td>ftruncate</td>
<td>参见truncate</td>
</tr>
<tr>
<td>umask</td>
<td>设置文件权限掩码</td>
</tr>
<tr>
<td>fsync</td>
<td>把文件在内存中的部分写回磁盘</td>
</tr>
</tbody>
</table>
<ul>
<li>文件系统操作</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>access</td>
<td>确定文件的可存取性</td>
</tr>
<tr>
<td>chdir</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td>fchdir</td>
<td>参见chdir</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件方式</td>
</tr>
<tr>
<td>fchmod</td>
<td>参见chmod</td>
</tr>
<tr>
<td>chown</td>
<td>改变文件的属主或用户组</td>
</tr>
<tr>
<td>fchown</td>
<td>参见chown</td>
</tr>
<tr>
<td>lchown</td>
<td>参见chown</td>
</tr>
<tr>
<td>chroot</td>
<td>改变根目录</td>
</tr>
<tr>
<td>stat</td>
<td>取文件状态信息</td>
</tr>
<tr>
<td>lstat</td>
<td>参见stat</td>
</tr>
<tr>
<td>fstat</td>
<td>参见stat</td>
</tr>
<tr>
<td>statfs</td>
<td>取文件系统信息</td>
</tr>
<tr>
<td>fstatfs</td>
<td>参见statfs</td>
</tr>
<tr>
<td>readdir</td>
<td>读取目录项</td>
</tr>
<tr>
<td>getdents</td>
<td>读取目录项</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td>mknod</td>
<td>创建索引节点</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除目录</td>
</tr>
<tr>
<td>rename</td>
<td>文件改名</td>
</tr>
<tr>
<td>link</td>
<td>创建链接</td>
</tr>
<tr>
<td>symlink</td>
<td>创建符号链接</td>
</tr>
<tr>
<td>unlink</td>
<td>删除链接</td>
</tr>
<tr>
<td>readlink</td>
<td>读符号链接的值</td>
</tr>
<tr>
<td>mount</td>
<td>安装文件系统</td>
</tr>
<tr>
<td>umount</td>
<td>卸下文件系统</td>
</tr>
<tr>
<td>ustat</td>
<td>取文件系统信息</td>
</tr>
<tr>
<td>utime</td>
<td>改变文件的访问修改时间</td>
</tr>
<tr>
<td>utimes</td>
<td>参见utime</td>
</tr>
<tr>
<td>quotactl</td>
<td>控制磁盘配额</td>
</tr>
</tbody>
</table>
<ul>
<li>系统控制</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ioctl</td>
<td>I/O总控制函数</td>
</tr>
<tr>
<td>_sysctl</td>
<td>读/写系统参数</td>
</tr>
<tr>
<td>acct</td>
<td>启用或禁止进程记账</td>
</tr>
<tr>
<td>getrlimit</td>
<td>获取系统资源上限</td>
</tr>
<tr>
<td>setrlimit</td>
<td>设置系统资源上限</td>
</tr>
<tr>
<td>getrusage</td>
<td>获取系统资源使用情况</td>
</tr>
<tr>
<td>uselib</td>
<td>选择要使用的二进制函数库</td>
</tr>
<tr>
<td>ioperm</td>
<td>设置端口I/O权限</td>
</tr>
<tr>
<td>iopl</td>
<td>改变进程I/O权限级别</td>
</tr>
<tr>
<td>outb</td>
<td>低级端口操作</td>
</tr>
<tr>
<td>reboot</td>
<td>重新启动</td>
</tr>
<tr>
<td>swapon</td>
<td>打开交换文件和设备</td>
</tr>
<tr>
<td>swapoff</td>
<td>关闭交换文件和设备</td>
</tr>
<tr>
<td>bdflush</td>
<td>控制bdflush守护进程</td>
</tr>
<tr>
<td>sysfs</td>
<td>取核心支持的文件系统类型</td>
</tr>
<tr>
<td>sysinfo</td>
<td>取得系统信息</td>
</tr>
<tr>
<td>adjtimex</td>
<td>调整系统时钟</td>
</tr>
<tr>
<td>alarm</td>
<td>设置进程的闹钟</td>
</tr>
<tr>
<td>getitimer</td>
<td>获取计时器值</td>
</tr>
<tr>
<td>setitimer</td>
<td>设置计时器值</td>
</tr>
<tr>
<td>gettimeofday</td>
<td>取时间和时区</td>
</tr>
<tr>
<td>settimeofday</td>
<td>设置时间和时区</td>
</tr>
<tr>
<td>stime</td>
<td>设置系统日期和时间</td>
</tr>
<tr>
<td>time</td>
<td>取得系统时间</td>
</tr>
<tr>
<td>times</td>
<td>取进程运行时间</td>
</tr>
<tr>
<td>uname</td>
<td>获取当前UNIX系统的名称、版本和主机等信息</td>
</tr>
<tr>
<td>vhangup</td>
<td>挂起当前终端</td>
</tr>
<tr>
<td>nfsservctl</td>
<td>对NFS守护进程进行控制</td>
</tr>
<tr>
<td>vm86</td>
<td>进入模拟8086模式</td>
</tr>
<tr>
<td>create_module</td>
<td>创建可装载的模块项</td>
</tr>
<tr>
<td>delete_module</td>
<td>删除可装载的模块项</td>
</tr>
<tr>
<td>init_module</td>
<td>初始化模块</td>
</tr>
<tr>
<td>query_module</td>
<td>查询模块信息</td>
</tr>
<tr>
<td>*get_kernel_syms</td>
<td>取得核心符号,已被query_module代替</td>
</tr>
</tbody>
</table>
<ul>
<li>内存管理</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>brk</td>
<td>改变数据段空间的分配</td>
</tr>
<tr>
<td>sbrk</td>
<td>参见brk</td>
</tr>
<tr>
<td>mlock</td>
<td>内存页面加锁</td>
</tr>
<tr>
<td>munlock</td>
<td>内存页面解锁</td>
</tr>
<tr>
<td>mlockall</td>
<td>调用进程所有内存页面加锁</td>
</tr>
<tr>
<td>munlockall</td>
<td>调用进程所有内存页面解锁</td>
</tr>
<tr>
<td>mmap</td>
<td>映射虚拟内存页</td>
</tr>
<tr>
<td>munmap</td>
<td>去除内存页映射</td>
</tr>
<tr>
<td>mremap</td>
<td>重新映射虚拟内存地址</td>
</tr>
<tr>
<td>msync</td>
<td>将映射内存中的数据写回磁盘</td>
</tr>
<tr>
<td>mprotect</td>
<td>设置内存映像保护</td>
</tr>
<tr>
<td>getpagesize</td>
<td>获取页面大小</td>
</tr>
<tr>
<td>sync</td>
<td>将内存缓冲区数据写回硬盘</td>
</tr>
<tr>
<td>cacheflush</td>
<td>将指定缓冲区中的内容写回磁盘</td>
</tr>
</tbody>
</table>
<ul>
<li>网络管理</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getdomainname</td>
<td>取域名</td>
</tr>
<tr>
<td>setdomainname</td>
<td>设置域名</td>
</tr>
<tr>
<td>gethostid</td>
<td>获取主机标识号</td>
</tr>
<tr>
<td>sethostid</td>
<td>设置主机标识号</td>
</tr>
<tr>
<td>gethostname</td>
<td>获取本主机名称</td>
</tr>
<tr>
<td>sethostname</td>
<td>设置主机名称</td>
</tr>
</tbody>
</table>
<ul>
<li>socket</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>socketcall</td>
<td>socket系统调用</td>
</tr>
<tr>
<td>socket</td>
<td>建立socket</td>
</tr>
<tr>
<td>bind</td>
<td>绑定socket到端口</td>
</tr>
<tr>
<td>connect</td>
<td>连接远程主机</td>
</tr>
<tr>
<td>accept</td>
<td>响应socket连接请求</td>
</tr>
<tr>
<td>send</td>
<td>通过socket发送信息</td>
</tr>
<tr>
<td>sendto</td>
<td>发送UDP信息</td>
</tr>
<tr>
<td>sendmsg</td>
<td>参见send</td>
</tr>
<tr>
<td>recv</td>
<td>通过socket接收信息</td>
</tr>
<tr>
<td>recvfrom</td>
<td>接收UDP信息</td>
</tr>
<tr>
<td>recvmsg</td>
<td>参见recv</td>
</tr>
<tr>
<td>listen</td>
<td>监听socket端口</td>
</tr>
<tr>
<td>select</td>
<td>对多路同步I/O进行轮询</td>
</tr>
<tr>
<td>shutdown</td>
<td>关闭socket上的连接</td>
</tr>
<tr>
<td>getsockname</td>
<td>取得本地socket名字</td>
</tr>
<tr>
<td>getpeername</td>
<td>获取通信对方的socket名字</td>
</tr>
<tr>
<td>getsockopt</td>
<td>取端口设置</td>
</tr>
<tr>
<td>setsockopt</td>
<td>设置端口参数</td>
</tr>
<tr>
<td>sendfile</td>
<td>在文件或端口间传输数据</td>
</tr>
<tr>
<td>socketpair</td>
<td>创建一对已联接的无名socket</td>
</tr>
</tbody>
</table>
<ul>
<li>用户管理</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getuid</td>
<td>获取用户标识号</td>
</tr>
<tr>
<td>setuid</td>
<td>设置用户标志号</td>
</tr>
<tr>
<td>getgid</td>
<td>获取组标识号</td>
</tr>
<tr>
<td>setgid</td>
<td>设置组标志号</td>
</tr>
<tr>
<td>getegid</td>
<td>获取有效组标识号</td>
</tr>
<tr>
<td>setegid</td>
<td>设置有效组标识号</td>
</tr>
<tr>
<td>geteuid</td>
<td>获取有效用户标识号</td>
</tr>
<tr>
<td>seteuid</td>
<td>设置有效用户标识号</td>
</tr>
<tr>
<td>setregid</td>
<td>分别设置真实和有效的的组标识号</td>
</tr>
<tr>
<td>setreuid</td>
<td>分别设置真实和有效的用户标识号</td>
</tr>
<tr>
<td>getresgid</td>
<td>分别获取真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td>setresgid</td>
<td>分别设置真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td>getresuid</td>
<td>分别获取真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td>setresuid</td>
<td>分别设置真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td>setfsgid</td>
<td>设置文件系统检查时使用的组标识号</td>
</tr>
<tr>
<td>setfsuid</td>
<td>设置文件系统检查时使用的用户标识号</td>
</tr>
<tr>
<td>getgroups</td>
<td>获取后补组标志清单</td>
</tr>
<tr>
<td>setgroups</td>
<td>设置后补组标志清单</td>
</tr>
</tbody>
</table>
<ul>
<li><p>进程间通信/ipc</p>
</li>
<li><p>信号</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sigaction</td>
<td>设置对指定信号的处理方法</td>
</tr>
<tr>
<td>sigprocmask</td>
<td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>
</tr>
<tr>
<td>sigpending</td>
<td>为指定的被阻塞信号设置队列</td>
</tr>
<tr>
<td>sigsuspend</td>
<td>挂起进程等待特定信号</td>
</tr>
<tr>
<td>signal</td>
<td>参见signal</td>
</tr>
<tr>
<td>kill</td>
<td>向进程或进程组发信号</td>
</tr>
<tr>
<td>*sigblock</td>
<td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>
</tr>
<tr>
<td>*siggetmask</td>
<td>取得现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigsetmask</td>
<td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigmask</td>
<td>将给定的信号转化为掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigpause</td>
<td>作用同sigsuspend,已被sigsuspend代替</td>
</tr>
<tr>
<td>sigvec</td>
<td>为兼容BSD而设的信号处理函数,作用类似sigaction</td>
</tr>
<tr>
<td>ssetmask</td>
<td>ANSI C的信号处理函数,作用类似sigaction</td>
</tr>
</tbody>
</table>
<ul>
<li>消息</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>msgctl</td>
<td>消息控制操作</td>
</tr>
<tr>
<td>msgget</td>
<td>获取消息队列</td>
</tr>
<tr>
<td>msgsnd</td>
<td>发消息</td>
</tr>
<tr>
<td>msgrcv</td>
<td>取消息</td>
</tr>
</tbody>
</table>
<ul>
<li>管道</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pipe</td>
<td>创建管道</td>
</tr>
</tbody>
</table>
<ul>
<li>信号量</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>semctl</td>
<td>信号量控制</td>
</tr>
<tr>
<td>semget</td>
<td>获取一组信号量</td>
</tr>
<tr>
<td>semop</td>
<td>信号量操作</td>
</tr>
</tbody>
</table>
<ul>
<li>共享内存</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>shmctl</td>
<td>控制共享内存</td>
</tr>
<tr>
<td>shmget</td>
<td>获取共享内存</td>
</tr>
<tr>
<td>shmat</td>
<td>连接共享内存</td>
</tr>
<tr>
<td>shmdt</td>
<td>拆卸共享内存</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.xuguruogu.com/2017/03/23/Linux系统调用列表-收藏/" data-id="cj0vzocz50001ges6nb1fy1jc" class="article-share-link">Compartir</a>
      
        <a href="http://blog.xuguruogu.com/2017/03/23/Linux系统调用列表-收藏/#disqus_thread" class="article-comment-link">Comentarios</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux路由分析mtr命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/linux路由分析mtr命令/" class="article-date">
  <time datetime="2017-03-19T13:24:05.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/linux路由分析mtr命令/">linux路由分析mtr命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux中有一个更好的网络连通性判断工具，它可以结合ping nslookup tracert 来判断网络的相关特性,这个命令就是mtr</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mtr -h 提供帮助命令 </div><div class="line">mtr -v 显示mtr的版本信息 </div><div class="line">mtr -r 已报告模式显示</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@10.10.90.97 ~]<span class="comment"># mtr -r 202.108.33.94</span></div><div class="line">FOCUS9097 Snt: 10 Loss% Last Avg Best Wrst StDev</div><div class="line">220.181.61.252 0.0% 6.8 3.3 1.8 7.4 2.2</div><div class="line">220.181.17.217 0.0% 0.4 0.5 0.4 0.7 0.1</div><div class="line">220.181.16.17 0.0% 0.6 0.5 0.5 0.6 0.0</div><div class="line">202.97.53.14 10.0% 0.7 0.7 0.7 0.8 0.0</div><div class="line">219.158.35.1 0.0% 0.8 0.8 0.8 0.9 0.0</div><div class="line">219.158.5.81 0.0% 1.2 1.3 1.2 1.6 0.1</div><div class="line">123.126.0.138 0.0% 1.2 1.1 1.1 1.3 0.1</div><div class="line">61.148.153.126 0.0% 1.9 10.5 1.5 89.9 27.9</div><div class="line">61.148.143.22 0.0% 1.5 1.6 1.5 1.7 0.0</div><div class="line">210.74.178.198 0.0% 1.6 1.6 1.5 1.9 0.1</div><div class="line">202.108.33.94 0.0% 1.5 1.5 1.4 1.5 0.0</div></pre></td></tr></table></figure>
<p>报告说明：<br>第一列:显示的是IP地址和本机域名，这点和tracert很像<br>第二列:snt:10 设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@10.10.90.97 ~]<span class="comment"># mtr -r -c 15 202.108.33.94</span></div><div class="line">FOCUS9097 Snt: 15 Loss% Last Avg Best Wrst StDev</div><div class="line">220.181.61.252 0.0% 1.9 3.4 1.8 12.9 3.1</div><div class="line">220.181.17.217 0.0% 0.5 0.5 0.4 0.8 0.1</div><div class="line">220.181.16.17 0.0% 0.5 0.6 0.5 2.3 0.5</div><div class="line">202.97.53.14 0.0% 0.7 0.7 0.7 0.7 0.0</div><div class="line">219.158.35.1 0.0% 0.9 0.8 0.8 0.9 0.0</div><div class="line">219.158.5.81 0.0% 1.3 2.8 1.2 22.8 5.5</div><div class="line">123.126.0.138 0.0% 1.1 1.1 1.1 1.2 0.0</div><div class="line">61.148.153.126 0.0% 13.8 7.4 1.6 60.4 15.5</div><div class="line">61.148.143.22 0.0% 1.7 1.6 1.5 1.8 0.1</div><div class="line">210.74.178.198 0.0% 1.6 1.6 1.4 1.7 0.1</div><div class="line">202.108.33.94 0.0% 1.5 1.5 1.4 1.7 0.1</div></pre></td></tr></table></figure>
<p>其中-c的说明是：–report-cycles COUNT</p>
<p>第三列:是显示的每个对应IP的丢包率<br>第四列:显示的最近一次的返回时延<br>第五列:是平均值 这个应该是发送ping包的平均时延<br>第六列:是最好或者说时延最短的<br>第七列:是最差或者说时延最常的<br>第八列:是标准偏差<br>接下来接着说相关参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mtr <span class="_">-s</span> 用来指定ping数据包的大小 </div><div class="line">mtr -n no-dns不对IP地址做域名解析 </div><div class="line">mtr <span class="_">-a</span> 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的 </div><div class="line">mtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒 </div><div class="line">mtr -4 IPv4 </div><div class="line">mtr -6 IPv6</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.xuguruogu.com/2017/03/19/linux路由分析mtr命令/" data-id="cj0vzoczp0005ges6249ow47l" class="article-share-link">Compartir</a>
      
        <a href="http://blog.xuguruogu.com/2017/03/19/linux路由分析mtr命令/#disqus_thread" class="article-comment-link">Comentarios</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/30/proc-irq-number-smp-affinity/">/proc/irq/{number}/smp_affinity</a>
          </li>
        
          <li>
            <a href="/2017/03/30/cpu含义/">cpu含义</a>
          </li>
        
          <li>
            <a href="/2017/03/30/linux下cpu物理个数、多核、超线程判断解析/">linux下cpu物理个数、多核、超线程判断解析</a>
          </li>
        
          <li>
            <a href="/2017/03/23/Linux系统调用列表-收藏/">Linux系统调用列表(收藏)</a>
          </li>
        
          <li>
            <a href="/2017/03/19/linux路由分析mtr命令/">linux路由分析mtr命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 kent<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'blog-xuguruogu-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>